{{- if and .Values.databases.postgres.enabled .Values.databases.postgres.restore.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "pyairtable-stack.fullname" . }}-postgres-restore-{{ .Values.databases.postgres.restore.timestamp }}
  namespace: {{ .Values.global.namespace }}
  labels:
    {{- include "pyairtable-stack.labels" . | nindent 4 }}
    app.kubernetes.io/component: postgres-restore
spec:
  ttlSecondsAfterFinished: {{ .Values.databases.postgres.restore.ttlSecondsAfterFinished | default 86400 }}
  backoffLimit: {{ .Values.databases.postgres.restore.backoffLimit | default 3 }}
  template:
    metadata:
      labels:
        {{- include "pyairtable-stack.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: postgres-restore
    spec:
      restartPolicy: Never
      initContainers:
      - name: wait-for-postgres
        image: "{{ .Values.databases.postgres.image }}:{{ .Values.databases.postgres.tag }}"
        command:
        - /bin/bash
        - -c
        - |
          echo "Waiting for PostgreSQL to be ready..."
          until pg_isready -h {{ .Values.databases.postgres.name }} -p {{ .Values.databases.postgres.port }} -U $POSTGRES_USER; do
            echo "PostgreSQL is not ready yet, waiting..."
            sleep 5
          done
          echo "PostgreSQL is ready!"
        env:
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: {{ include "pyairtable-stack.fullname" . }}-secrets
              key: POSTGRES_USER
      containers:
      - name: postgres-restore
        image: "{{ .Values.databases.postgres.image }}:{{ .Values.databases.postgres.tag }}"
        imagePullPolicy: {{ .Values.global.imagePullPolicy }}
        command:
        - /bin/bash
        - -c
        - |
          set -euo pipefail
          
          echo "Starting PostgreSQL restore at $(date)"
          
          BACKUP_FILE="{{ .Values.databases.postgres.restore.backupFile }}"
          
          if [ ! -f "$BACKUP_FILE" ]; then
            echo "Error: Backup file '$BACKUP_FILE' not found"
            exit 1
          fi
          
          echo "Restoring from backup file: $BACKUP_FILE"
          echo "Backup file size: $(du -h $BACKUP_FILE | cut -f1)"
          
          {{- if .Values.databases.postgres.restore.dropDatabase }}
          # Drop and recreate database (if configured)
          echo "Dropping existing database..."
          psql -h {{ .Values.databases.postgres.name }} \
               -p {{ .Values.databases.postgres.port }} \
               -U "$POSTGRES_USER" \
               -d postgres \
               -c "DROP DATABASE IF EXISTS $POSTGRES_DB;"
          
          echo "Creating fresh database..."
          psql -h {{ .Values.databases.postgres.name }} \
               -p {{ .Values.databases.postgres.port }} \
               -U "$POSTGRES_USER" \
               -d postgres \
               -c "CREATE DATABASE $POSTGRES_DB;"
          {{- else }}
          echo "Cleaning existing data (keeping database structure)..."
          {{- end }}
          
          # Restore the backup
          echo "Restoring database from backup..."
          pg_restore -h {{ .Values.databases.postgres.name }} \
                     -p {{ .Values.databases.postgres.port }} \
                     -U "$POSTGRES_USER" \
                     -d "$POSTGRES_DB" \
                     --verbose \
                     --no-password \
                     {{- if .Values.databases.postgres.restore.cleanFirst }}
                     --clean \
                     {{- end }}
                     {{- if .Values.databases.postgres.restore.createTables }}
                     --create \
                     {{- end }}
                     --if-exists \
                     --single-transaction \
                     "$BACKUP_FILE"
          
          echo "Restore completed successfully at $(date)"
          
          # Verify restore
          echo "Verifying restored database..."
          TABLES=$(psql -h {{ .Values.databases.postgres.name }} \
                       -p {{ .Values.databases.postgres.port }} \
                       -U "$POSTGRES_USER" \
                       -d "$POSTGRES_DB" \
                       -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';")
          
          echo "Restored database contains $TABLES tables"
          
          if [ "$TABLES" -gt 0 ]; then
            echo "Database restore verification successful!"
          else
            echo "Warning: No tables found in restored database"
          fi
        env:
        - name: POSTGRES_DB
          valueFrom:
            secretKeyRef:
              name: {{ include "pyairtable-stack.fullname" . }}-secrets
              key: POSTGRES_DB
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: {{ include "pyairtable-stack.fullname" . }}-secrets
              key: POSTGRES_USER
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ include "pyairtable-stack.fullname" . }}-secrets
              key: POSTGRES_PASSWORD
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ include "pyairtable-stack.fullname" . }}-secrets
              key: POSTGRES_PASSWORD
        volumeMounts:
        - name: backup-storage
          mountPath: /backups
          readOnly: true
        resources:
          {{- toYaml .Values.databases.postgres.restore.resources | nindent 10 }}
      volumes:
      - name: backup-storage
        persistentVolumeClaim:
          claimName: {{ include "pyairtable-stack.fullname" . }}-postgres-backup-pvc
{{- end }}