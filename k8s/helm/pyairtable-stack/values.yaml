# Global configuration
global:
  namespace: pyairtable
  imageRegistry: ghcr.io/reg-kris
  imagePullPolicy: IfNotPresent
  storageClassName: standard

# Application configuration
app:
  environment: development
  logLevel: info
  
# Service configurations
services:
  # API Gateway - Main entry point
  apiGateway:
    enabled: true
    name: api-gateway
    image: pyairtable-api-gateway
    tag: latest
    port: 8000
    replicas: 1
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi

  # LLM Orchestrator - Gemini 2.5 Flash integration
  llmOrchestrator:
    enabled: true
    name: llm-orchestrator
    image: llm-orchestrator-py
    tag: latest
    port: 8003
    replicas: 1
    resources:
      limits:
        cpu: 1000m
        memory: 1Gi
      requests:
        cpu: 500m
        memory: 512Mi

  # MCP Server - Protocol implementation
  mcpServer:
    enabled: true
    name: mcp-server
    image: mcp-server-py
    tag: latest
    port: 8001
    replicas: 1
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi

  # Airtable Gateway - Direct Airtable API integration
  airtableGateway:
    enabled: true
    name: airtable-gateway
    image: airtable-gateway-py
    tag: latest
    port: 8002
    replicas: 1
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi

  # Platform Services - Unified Auth & Analytics
  platformServices:
    enabled: true
    name: platform-services
    image: pyairtable-platform-services
    tag: latest
    port: 8007
    replicas: 1
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi

  # Automation Services - File processing and workflow automation
  automationServices:
    enabled: true
    name: automation-services
    image: pyairtable-automation-services
    tag: latest
    port: 8006
    replicas: 1
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi

  # Frontend - Next.js web interface
  frontend:
    enabled: true
    name: frontend
    image: pyairtable-frontend
    tag: latest
    port: 3000
    replicas: 1
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 250m
        memory: 256Mi

# Database services
databases:
  # PostgreSQL
  postgres:
    enabled: true
    name: postgres
    image: postgres
    tag: 16-alpine
    port: 5432
    replicas: 1
    resources:
      limits:
        cpu: 500m
        memory: 1Gi
      requests:
        cpu: 250m
        memory: 512Mi
    
    # Security context
    securityContext:
      enabled: true
      fsGroup: 999
      runAsUser: 999
      runAsGroup: 999
    
    # Service account
    serviceAccount:
      create: true
      annotations: {}
    
    # Service configuration
    service:
      type: ClusterIP
      annotations: {}
    
    # PostgreSQL configuration
    config:
      maxConnections: 200
      sharedBuffers: "256MB"
      effectiveCacheSize: "1GB"
      workMem: "4MB"
      maintenanceWorkMem: "64MB"
      checkpointCompletionTarget: 0.9
      maxWalSize: "1GB"
      minWalSize: "80MB"
      walLevel: "replica"
      maxWalSenders: 3
      maxReplicationSlots: 3
      hotStandby: "on"
      logStatement: "'none'"
      logDuration: "off"
      randomPageCost: 1.1
      effectiveIoConcurrency: 200
      extraConfig: ""
      extraHbaConfig: ""
    
    # Persistence configuration
    persistence:
      enabled: true
      size: 10Gi
      storageClass: postgres-dev-ssd
      accessModes:
        - ReadWriteOnce
      annotations: {}
    
    # Metrics and monitoring
    metrics:
      enabled: true
      image: prometheuscommunity/postgres-exporter
      tag: v0.15.0
      resources:
        requests:
          cpu: 50m
          memory: 64Mi
        limits:
          cpu: 100m
          memory: 128Mi
    
    # Monitoring and alerting
    monitoring:
      enabled: true
      scrapeInterval: "30s"
      scrapeTimeout: "10s"
      evaluationInterval: "30s"
      alerts:
        diskUsageThreshold: 85
        diskUsageWarningThreshold: 70
        ioErrorThreshold: 0.1
        connectionThreshold: 80
        replicationLagThreshold: 60
        backupFailureThreshold: 86400
        slowQueryThreshold: 1000
        deadlockThreshold: 0.01
        pvcUsageThreshold: 85
      customMetrics:
        enabled: true
        schedule: "*/5 * * * *"
      pushgateway:
        enabled: false
        url: "http://pushgateway:9091"
    
    # Backup configuration
    backup:
      enabled: true
      schedule: "0 2 * * *"
      retentionDays: 7
      storageSize: "50Gi"
      storageClass: postgres-backup-standard
      uploadToCloud: false
      successfulJobsHistoryLimit: 3
      failedJobsHistoryLimit: 1
      startingDeadlineSeconds: 300
      resources:
        requests:
          cpu: 100m
          memory: 256Mi
        limits:
          cpu: 500m
          memory: 512Mi
    
    # Restore configuration
    restore:
      enabled: false
      timestamp: "latest"
      backupFile: "/backups/postgres/postgres_backup_latest.sql.gz"
      dropDatabase: false
      cleanFirst: true
      createTables: false
      ttlSecondsAfterFinished: 86400
      backoffLimit: 3
      resources:
        requests:
          cpu: 100m
          memory: 256Mi
        limits:
          cpu: 500m
          memory: 512Mi
    
    # Volume snapshots
    snapshots:
      enabled: true
      driver: "pd.csi.storage.gke.io"
      deletionPolicy: "Retain"
      isDefault: false
      schedule: "0 3 * * *"
      retentionCount: 7
      successfulJobsHistoryLimit: 3
      failedJobsHistoryLimit: 1
      startingDeadlineSeconds: 300
      image: "bitnami/kubectl:latest"
      parameters: {}
    
    # Replication configuration
    replication:
      enabled: false
      replicas: 1
      password: "replication_password"
      resources:
        requests:
          cpu: 250m
          memory: 512Mi
        limits:
          cpu: 500m
          memory: 1Gi
      persistence:
        size: 10Gi
        storageClass: postgres-staging-balanced
        accessModes:
          - ReadWriteOnce
      config:
        maxConnections: 100
        sharedBuffers: "128MB"
        effectiveCacheSize: "512MB"
        workMem: "2MB"
        maintenanceWorkMem: "32MB"
        hotStandbyFeedback: "on"
        maxStandbyArchiveDelay: "30s"
        maxStandbyStreamingDelay: "30s"
        randomPageCost: 1.1
        effectiveIoConcurrency: 200
        primarySlotName: "'replica_slot'"
        restoreCommand: "'cp /var/lib/postgresql/archive/%f %p'"
        archiveCleanupCommand: "'pg_archivecleanup /var/lib/postgresql/archive %r'"
        recoveryTargetAction: "'promote'"
        extraConfig: ""
        extraRecoveryConfig: ""
      nodeSelector: {}
      tolerations: []
      affinity: {}
      # Cross-region replication
      crossRegion:
        enabled: false
        schedule: "0 */6 * * *"
        provider: "gcs"  # Options: gcs, s3, azure
        bucket: "my-backup-bucket"
        container: "backup-container"  # For Azure
        credentials: {}
    
    # Migration configuration
    migration:
      enabled: false
      version: "1.0.0"
      description: "Database migration"
      createBackup: true
      ttlSecondsAfterFinished: 86400
      backoffLimit: 3
      resources:
        requests:
          cpu: 100m
          memory: 256Mi
        limits:
          cpu: 500m
          memory: 512Mi
      scripts: {}
      validation:
        enabled: true
        queries:
          - "SELECT 1;"
    
    # Extra environment variables
    extraEnvVars: []

  # Redis
  redis:
    enabled: true
    name: redis
    image: redis
    tag: 7-alpine
    port: 6379
    replicas: 1
    resources:
      limits:
        cpu: 250m
        memory: 256Mi
      requests:
        cpu: 100m
        memory: 128Mi
    persistence:
      enabled: true
      size: 1Gi
      storageClass: standard

# Persistent volumes
persistence:
  fileUploads:
    enabled: true
    size: 5Gi
    storageClass: standard

# Storage Classes Configuration
storageClasses:
  create: true
  
  # Development environment storage class
  dev:
    provisioner: "kubernetes.io/no-provisioner"
    type: "ssd"
    fsType: "ext4"
    encrypted: false
    volumeBindingMode: "WaitForFirstConsumer"
    allowVolumeExpansion: true
    reclaimPolicy: "Delete"
    isDefault: false
    mountOptions: []
  
  # Staging environment storage class
  staging:
    provisioner: "kubernetes.io/gce-pd"
    type: "pd-balanced"
    fsType: "ext4"
    encrypted: true
    zones: "us-central1-a,us-central1-b,us-central1-c"
    replicationType: "regional-pd"
    volumeBindingMode: "WaitForFirstConsumer"
    allowVolumeExpansion: true
    reclaimPolicy: "Retain"
    mountOptions: []
  
  # Production environment storage class
  prod:
    provisioner: "kubernetes.io/gce-pd"
    type: "pd-ssd"
    fsType: "ext4"
    encrypted: true
    zones: "us-central1-a,us-central1-b,us-central1-c"
    replicationType: "regional-pd"
    iops: "10000"
    throughput: "400"
    volumeBindingMode: "WaitForFirstConsumer"
    allowVolumeExpansion: true
    reclaimPolicy: "Retain"
    mountOptions:
      - "discard"
  
  # Backup storage class
  backup:
    provisioner: "kubernetes.io/gce-pd"
    type: "pd-standard"
    fsType: "ext4"
    encrypted: true
    zones: "us-central1-a,us-central1-b,us-central1-c"
    volumeBindingMode: "Immediate"
    allowVolumeExpansion: true
    reclaimPolicy: "Retain"
    mountOptions: []

# Service exposure
ingress:
  enabled: true
  className: nginx
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
  hosts:
    - host: pyairtable.local
      paths:
        - path: /
          pathType: Prefix
          service: frontend
          port: 3000
        - path: /api
          pathType: Prefix
          service: api-gateway
          port: 8000

# Environment variables (these will be created as secrets)
# SECURITY WARNING: These are placeholder values. Never commit actual secrets!
# 
# For local development:
#   kubectl create secret generic pyairtable-secrets --from-env-file=.env
# 
# For production, use one of these approaches:
#   1. External Secrets Operator: https://external-secrets.io/
#   2. Sealed Secrets: https://sealed-secrets.netlify.app/
#   3. Helm --set-string flags: --set-string secrets.apiKey=$API_KEY
#   4. CI/CD pipeline with secret injection
secrets:
  # CRITICAL: Replace with actual values via external secret management
  apiKey: ""  # Internal service-to-service API key
  geminiApiKey: "AIzaSyCwAGazN5GMCu03ZYLFWWTkdLRKFQb-OxU"  # Google Gemini API key from cloud console
  airtableToken: "patewow2oXotOdgpz.c7e78f8a5d17f20dfcbe7d32736dd06f56916af7e1549d88ed8f6791a2eaf654"  # Airtable Personal Access Token
  airtableBase: "appVLUAubH5cFWhMV"  # Airtable Base ID (format: appXXXXXXXXXXXXXX)
  jwtSecret: ""  # JWT signing secret (64+ characters)
  nextauthSecret: ""  # NextAuth session secret (64+ characters)
  redisPassword: ""  # Redis authentication password
  
  # Database credentials
  postgresDb: pyairtable
  postgresUser: postgres
  postgresPassword: ""  # PostgreSQL password (16+ characters)
  postgresReplicationPassword: ""  # PostgreSQL replication password
  
  # Optional configuration
  thinkingBudget: "1000"
  corsOrigins: "*"
  maxFileSize: "10MB"
  allowedExtensions: "pdf,doc,docx,txt,csv,xlsx"

# Health checks
healthChecks:
  enabled: true
  initialDelaySeconds: 30
  periodSeconds: 30
  timeoutSeconds: 10
  failureThreshold: 3
  successThreshold: 1

# Horizontal Pod Autoscaler
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 5
  targetCPUUtilizationPercentage: 80
  targetMemoryUtilizationPercentage: 80