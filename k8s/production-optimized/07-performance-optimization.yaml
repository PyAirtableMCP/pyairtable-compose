# Performance Optimization Configuration for PyAirtable Production
---
# PostgreSQL Performance Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: postgres-performance-config
  namespace: pyairtable
data:
  postgresql.conf: |
    # Connection Settings
    max_connections = 200
    superuser_reserved_connections = 3
    
    # Memory Settings
    shared_buffers = 256MB
    effective_cache_size = 1GB
    work_mem = 8MB
    maintenance_work_mem = 128MB
    
    # WAL Settings
    wal_buffers = 16MB
    checkpoint_completion_target = 0.9
    checkpoint_timeout = 10min
    max_wal_size = 1GB
    min_wal_size = 256MB
    
    # Query Planning
    random_page_cost = 1.1
    effective_io_concurrency = 200
    
    # Logging
    log_min_duration_statement = 1000
    log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
    log_statement = 'ddl'
    log_lock_waits = on
    log_temp_files = 0
    
    # Autovacuum
    autovacuum = on
    autovacuum_max_workers = 4
    autovacuum_naptime = 30s
    autovacuum_vacuum_threshold = 50
    autovacuum_analyze_threshold = 50
    
    # Performance tuning
    max_worker_processes = 8
    max_parallel_workers = 8
    max_parallel_workers_per_gather = 4
    max_parallel_maintenance_workers = 4
    
    # Connection pooling support
    tcp_keepalives_idle = 600
    tcp_keepalives_interval = 30
    tcp_keepalives_count = 3

---
# Optimized PostgreSQL StatefulSet
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgres-optimized
  namespace: pyairtable
  labels:
    app: postgres
    version: optimized
spec:
  serviceName: postgres-service
  replicas: 1
  selector:
    matchLabels:
      app: postgres
      version: optimized
  template:
    metadata:
      labels:
        app: postgres
        version: optimized
    spec:
      serviceAccountName: pyairtable-sa
      securityContext:
        runAsUser: 999
        runAsGroup: 999
        fsGroup: 999
      initContainers:
      - name: postgres-init
        image: postgres:15-alpine
        command:
        - sh
        - -c
        - |
          if [ ! -f /var/lib/postgresql/data/postgresql.conf ]; then
            initdb -D /var/lib/postgresql/data
          fi
          cp /etc/postgresql/postgresql.conf /var/lib/postgresql/data/
          chown postgres:postgres /var/lib/postgresql/data/postgresql.conf
        volumeMounts:
        - name: postgres-config
          mountPath: /etc/postgresql
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
      containers:
      - name: postgres
        image: postgres:15-alpine
        ports:
        - name: postgres
          containerPort: 5432
          protocol: TCP
        env:
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: pyairtable-secrets
              key: postgres-user
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: pyairtable-secrets
              key: postgres-password
        - name: POSTGRES_DB
          valueFrom:
            secretKeyRef:
              name: pyairtable-secrets
              key: postgres-db
        - name: PGDATA
          value: /var/lib/postgresql/data
        resources:
          requests:
            memory: "1Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        livenessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - $(POSTGRES_USER)
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - pg_isready
            - -U
            - $(POSTGRES_USER)
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: postgres-data
          mountPath: /var/lib/postgresql/data
        - name: postgres-config
          mountPath: /etc/postgresql
          readOnly: true
      # PostgreSQL Exporter for monitoring
      - name: postgres-exporter
        image: prometheuscommunity/postgres-exporter:v0.15.0
        ports:
        - name: metrics
          containerPort: 9187
          protocol: TCP
        env:
        - name: DATA_SOURCE_NAME
          value: "postgresql://$(POSTGRES_USER):$(POSTGRES_PASSWORD)@localhost:5432/$(POSTGRES_DB)?sslmode=disable"
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: pyairtable-secrets
              key: postgres-user
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: pyairtable-secrets
              key: postgres-password
        - name: POSTGRES_DB
          valueFrom:
            secretKeyRef:
              name: pyairtable-secrets
              key: postgres-db
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
      volumes:
      - name: postgres-config
        configMap:
          name: postgres-performance-config
      affinity:
        podAntiAffinity:
          preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchLabels:
                  app: postgres
              topologyKey: kubernetes.io/hostname
  volumeClaimTemplates:
  - metadata:
      name: postgres-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 100Gi
      storageClassName: fast-ssd

---
# PgBouncer Connection Pooler
apiVersion: v1
kind: ConfigMap
metadata:
  name: pgbouncer-config
  namespace: pyairtable
data:
  pgbouncer.ini: |
    [databases]
    * = host=postgres-service port=5432
    
    [pgbouncer]
    listen_addr = 0.0.0.0
    listen_port = 6432
    auth_type = md5
    auth_file = /etc/pgbouncer/userlist.txt
    
    # Connection pooling settings
    pool_mode = transaction
    max_client_conn = 1000
    default_pool_size = 100
    max_db_connections = 100
    max_user_connections = 100
    reserve_pool_size = 10
    reserve_pool_timeout = 5
    
    # Performance settings
    server_check_delay = 30
    server_check_query = SELECT 1
    server_lifetime = 3600
    server_idle_timeout = 600
    
    # Logging
    log_connections = 1
    log_disconnections = 1
    log_pooler_errors = 1
  
  userlist.txt: |
    "admin" "md5d033e22ae348aeb5660fc2140aec35850c4da997"

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pgbouncer
  namespace: pyairtable
  labels:
    app: pgbouncer
spec:
  replicas: 2
  selector:
    matchLabels:
      app: pgbouncer
  template:
    metadata:
      labels:
        app: pgbouncer
    spec:
      containers:
      - name: pgbouncer
        image: pgbouncer/pgbouncer:1.21.0
        ports:
        - name: pgbouncer
          containerPort: 6432
        env:
        - name: DATABASES_HOST
          value: postgres-service
        - name: DATABASES_PORT
          value: "5432"
        - name: DATABASES_USER
          valueFrom:
            secretKeyRef:
              name: pyairtable-secrets
              key: postgres-user
        - name: DATABASES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: pyairtable-secrets
              key: postgres-password
        - name: DATABASES_DBNAME
          valueFrom:
            secretKeyRef:
              name: pyairtable-secrets
              key: postgres-db
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
        livenessProbe:
          tcpSocket:
            port: 6432
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          tcpSocket:
            port: 6432
          initialDelaySeconds: 5
          periodSeconds: 5
        volumeMounts:
        - name: pgbouncer-config
          mountPath: /etc/pgbouncer
          readOnly: true
      volumes:
      - name: pgbouncer-config
        configMap:
          name: pgbouncer-config

---
apiVersion: v1
kind: Service
metadata:
  name: pgbouncer
  namespace: pyairtable
  labels:
    app: pgbouncer
spec:
  selector:
    app: pgbouncer
  ports:
    - port: 6432
      targetPort: 6432
      name: pgbouncer
  type: ClusterIP

---
# Message Queue (Apache Kafka) for Async Processing
apiVersion: v1
kind: ConfigMap
metadata:
  name: kafka-config
  namespace: pyairtable
data:
  server.properties: |
    # Broker settings
    broker.id=1
    listeners=PLAINTEXT://0.0.0.0:9092
    advertised.listeners=PLAINTEXT://kafka-service:9092
    
    # Log settings
    log.dirs=/kafka/kafka-logs
    num.network.threads=8
    num.io.threads=16
    socket.send.buffer.bytes=102400
    socket.receive.buffer.bytes=102400
    socket.request.max.bytes=104857600
    
    # Partition settings
    num.partitions=3
    num.recovery.threads.per.data.dir=2
    offsets.topic.replication.factor=1
    transaction.state.log.replication.factor=1
    transaction.state.log.min.isr=1
    
    # Log retention
    log.retention.hours=168
    log.segment.bytes=1073741824
    log.retention.check.interval.ms=300000
    
    # Zookeeper
    zookeeper.connect=zookeeper-service:2181
    zookeeper.connection.timeout.ms=18000
    
    # Performance tuning
    replica.fetch.max.bytes=1048576
    message.max.bytes=1000000
    replica.fetch.wait.max.ms=500
    fetch.purgatory.purge.interval.requests=1000
    producer.purgatory.purge.interval.requests=1000

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: kafka
  namespace: pyairtable
  labels:
    app: kafka
spec:
  serviceName: kafka-service
  replicas: 1
  selector:
    matchLabels:
      app: kafka
  template:
    metadata:
      labels:
        app: kafka
    spec:
      containers:
      - name: kafka
        image: confluentinc/cp-kafka:7.4.0
        ports:
        - name: kafka
          containerPort: 9092
        env:
        - name: KAFKA_ZOOKEEPER_CONNECT
          value: zookeeper-service:2181
        - name: KAFKA_ADVERTISED_LISTENERS
          value: PLAINTEXT://kafka-service:9092
        - name: KAFKA_LISTENERS
          value: PLAINTEXT://0.0.0.0:9092
        - name: KAFKA_BROKER_ID
          value: "1"
        - name: KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR
          value: "1"
        - name: KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR
          value: "1"
        - name: KAFKA_TRANSACTION_STATE_LOG_MIN_ISR
          value: "1"
        - name: KAFKA_JVM_PERFORMANCE_OPTS
          value: "-XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35"
        - name: KAFKA_HEAP_OPTS
          value: "-Xmx1G -Xms1G"
        resources:
          requests:
            memory: "1.5Gi"
            cpu: "500m"
          limits:
            memory: "2Gi"
            cpu: "1000m"
        volumeMounts:
        - name: kafka-data
          mountPath: /kafka
        - name: kafka-config
          mountPath: /etc/kafka
        livenessProbe:
          tcpSocket:
            port: 9092
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          tcpSocket:
            port: 9092
          initialDelaySeconds: 15
          periodSeconds: 5
      volumes:
      - name: kafka-config
        configMap:
          name: kafka-config
  volumeClaimTemplates:
  - metadata:
      name: kafka-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 50Gi
      storageClassName: fast-ssd

---
# Zookeeper for Kafka
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: zookeeper
  namespace: pyairtable
  labels:
    app: zookeeper
spec:
  serviceName: zookeeper-service
  replicas: 1
  selector:
    matchLabels:
      app: zookeeper
  template:
    metadata:
      labels:
        app: zookeeper
    spec:
      containers:
      - name: zookeeper
        image: confluentinc/cp-zookeeper:7.4.0
        ports:
        - name: zookeeper
          containerPort: 2181
        env:
        - name: ZOOKEEPER_CLIENT_PORT
          value: "2181"
        - name: ZOOKEEPER_TICK_TIME
          value: "2000"
        - name: ZOOKEEPER_SYNC_LIMIT
          value: "5"
        - name: ZOOKEEPER_INIT_LIMIT
          value: "10"
        - name: ZOOKEEPER_MAX_CLIENT_CNXNS
          value: "60"
        - name: ZOOKEEPER_AUTOPURGE_SNAP_RETAIN_COUNT
          value: "3"
        - name: ZOOKEEPER_AUTOPURGE_PURGE_INTERVAL
          value: "24"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        volumeMounts:
        - name: zookeeper-data
          mountPath: /var/lib/zookeeper/data
        - name: zookeeper-logs
          mountPath: /var/lib/zookeeper/log
        livenessProbe:
          exec:
            command:
            - /bin/bash
            - -c
            - "echo ruok | nc localhost 2181 | grep imok"
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command:
            - /bin/bash
            - -c
            - "echo ruok | nc localhost 2181 | grep imok"
          initialDelaySeconds: 15
          periodSeconds: 5
  volumeClaimTemplates:
  - metadata:
      name: zookeeper-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi
  - metadata:
      name: zookeeper-logs
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi

---
# Kafka and Zookeeper Services
apiVersion: v1
kind: Service
metadata:
  name: kafka-service
  namespace: pyairtable
  labels:
    app: kafka
spec:
  selector:
    app: kafka
  ports:
    - port: 9092
      targetPort: 9092
      name: kafka
  type: ClusterIP

---
apiVersion: v1
kind: Service
metadata:
  name: zookeeper-service
  namespace: pyairtable
  labels:
    app: zookeeper
spec:
  selector:
    app: zookeeper
  ports:
    - port: 2181
      targetPort: 2181
      name: zookeeper
  type: ClusterIP

---
# Performance Monitoring Configuration
apiVersion: v1
kind: ConfigMap
metadata:
  name: performance-monitoring
  namespace: pyairtable
data:
  performance-alerts.yaml: |
    groups:
    - name: performance.rules
      rules:
      - alert: HighCPUUsage
        expr: rate(container_cpu_usage_seconds_total[5m]) > 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High CPU usage detected"
          description: "CPU usage is above 80% for more than 5 minutes"
      
      - alert: HighMemoryUsage
        expr: container_memory_usage_bytes / container_spec_memory_limit_bytes > 0.9
        for: 2m
        labels:
          severity: critical
        annotations:
          summary: "High memory usage detected"
          description: "Memory usage is above 90%"
      
      - alert: SlowDatabaseQueries
        expr: pg_stat_activity_max_tx_duration{datname="pyairtablemcp"} > 30
        for: 1m
        labels:
          severity: warning
        annotations:
          summary: "Slow database queries detected"
          description: "Database queries taking longer than 30 seconds"
      
      - alert: HighAPILatency
        expr: histogram_quantile(0.95, rate(http_request_duration_seconds_bucket[5m])) > 2
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High API latency detected"
          description: "95th percentile latency is above 2 seconds"