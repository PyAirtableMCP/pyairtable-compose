apiVersion: v1
kind: ConfigMap
metadata:
  name: chaos-guardrails-config
  namespace: chaos-engineering
data:
  guardrails.yaml: |
    # PyAirtable Chaos Engineering Guardrails Configuration
    
    # Global settings
    global:
      max_concurrent_experiments: 3
      max_experiment_duration: "30m"
      emergency_stop_threshold: 80  # Percentage of failing services
      monitoring_required: true
      approval_required_for_production: true
    
    # Namespace restrictions
    allowed_namespaces:
      - pyairtable
      - pyairtable-dev
      - pyairtable-staging
    
    forbidden_namespaces:
      - kube-system
      - kube-public
      - chaos-engineering
      - monitoring
      - istio-system
    
    # Resource limits
    resource_limits:
      cpu_stress_max_workers: 4
      memory_stress_max_size: "1Gi"
      io_stress_max_workers: 2
      network_delay_max_latency: "5s"
      network_loss_max_percent: 50
    
    # Service protection
    protected_services:
      critical:
        - api-gateway
        - auth-service
        - postgres
      
      restricted_actions:
        postgres:
          - pod-kill  # Database restarts require special approval
        auth-service:
          - pod-kill
          - network-partition
    
    # Time windows
    allowed_time_windows:
      weekdays:
        start: "09:00"
        end: "17:00"
        timezone: "UTC"
      
      production_freeze:
        # No experiments during these periods
        periods:
          - start: "2024-12-24T00:00:00Z"
            end: "2024-12-26T23:59:59Z"
            reason: "Holiday freeze"
    
    # Automatic rollback triggers
    auto_rollback:
      enabled: true
      triggers:
        service_availability_below: 60  # Percentage
        error_rate_above: 10           # Errors per second
        response_time_above: "10s"     # P95 response time
        memory_usage_above: 90         # Percentage
        cpu_usage_above: 95            # Percentage
    
    # Required approvals
    approvals:
      production_experiments:
        required: true
        approvers:
          - platform-team
          - sre-team
      
      destructive_experiments:
        required: true
        approvers:
          - platform-lead
        experiments:
          - pod-kill
          - network-partition
          - io-fault

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: chaos-guardrails
  namespace: chaos-engineering

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: chaos-guardrails-role
rules:
- apiGroups: ["chaos-mesh.org"]
  resources: ["*"]
  verbs: ["get", "list", "watch", "create", "update", "patch", "delete"]
- apiGroups: [""]
  resources: ["pods", "services", "endpoints"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments", "replicasets"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["metrics.k8s.io"]
  resources: ["pods", "nodes"]
  verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: chaos-guardrails-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: chaos-guardrails-role
subjects:
- kind: ServiceAccount
  name: chaos-guardrails
  namespace: chaos-engineering

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: chaos-guardrails-controller
  namespace: chaos-engineering
spec:
  replicas: 1
  selector:
    matchLabels:
      app: chaos-guardrails-controller
  template:
    metadata:
      labels:
        app: chaos-guardrails-controller
    spec:
      serviceAccountName: chaos-guardrails
      containers:
      - name: controller
        image: python:3.9-slim
        command: ["/bin/sh"]
        args:
          - -c
          - |
            pip install kubernetes prometheus-client
            cat > /app/guardrails_controller.py << 'EOF'
            #!/usr/bin/env python3
            import os
            import yaml
            import time
            import logging
            from datetime import datetime
            from kubernetes import client, config, watch
            from prometheus_client.parser import text_string_to_metric_families
            import requests
            
            logging.basicConfig(level=logging.INFO)
            logger = logging.getLogger(__name__)
            
            class ChaosGuardrailsController:
                def __init__(self):
                    config.load_incluster_config()
                    self.k8s_client = client.ApiClient()
                    self.custom_api = client.CustomObjectsApi()
                    self.core_api = client.CoreV1Api()
                    
                    # Load guardrails config
                    with open('/etc/config/guardrails.yaml', 'r') as f:
                        self.config = yaml.safe_load(f)
                    
                    logger.info("Chaos Guardrails Controller started")
                
                def validate_experiment(self, experiment):
                    """Validate experiment against guardrails"""
                    
                    # Check namespace restrictions
                    namespace = experiment.get('metadata', {}).get('namespace')
                    if namespace in self.config.get('forbidden_namespaces', []):
                        return False, f"Namespace {namespace} is forbidden"
                    
                    if namespace not in self.config.get('allowed_namespaces', []):
                        return False, f"Namespace {namespace} is not allowed"
                    
                    # Check resource limits
                    spec = experiment.get('spec', {})
                    if 'stressors' in spec:
                        cpu_workers = spec['stressors'].get('cpu', {}).get('workers', 0)
                        if cpu_workers > self.config['resource_limits']['cpu_stress_max_workers']:
                            return False, f"CPU stress workers exceed limit: {cpu_workers}"
                    
                    # Check time windows
                    current_time = datetime.now()
                    if not self.is_allowed_time(current_time):
                        return False, "Current time is outside allowed experiment windows"
                    
                    return True, "Experiment validation passed"
                
                def is_allowed_time(self, current_time):
                    """Check if current time is within allowed experiment windows"""
                    # Simplified implementation - in production, implement full time window logic
                    hour = current_time.hour
                    return 9 <= hour <= 17  # Only allow experiments during business hours
                
                def check_system_health(self):
                    """Check overall system health before allowing experiments"""
                    try:
                        # Get pod status
                        pods = self.core_api.list_namespaced_pod(namespace='pyairtable')
                        running_pods = sum(1 for pod in pods.items if pod.status.phase == 'Running')
                        total_pods = len(pods.items)
                        
                        if total_pods == 0:
                            return False, "No pods found in target namespace"
                        
                        availability = (running_pods / total_pods) * 100
                        
                        if availability < self.config['auto_rollback']['triggers']['service_availability_below']:
                            return False, f"Service availability too low: {availability}%"
                        
                        return True, f"System health OK: {availability}% availability"
                    
                    except Exception as e:
                        logger.error(f"Health check failed: {e}")
                        return False, f"Health check error: {e}"
                
                def monitor_experiments(self):
                    """Monitor running experiments and trigger rollbacks if needed"""
                    while True:
                        try:
                            # Check for running experiments
                            experiments = self.custom_api.list_namespaced_custom_object(
                                group="chaos-mesh.org",
                                version="v1alpha1",
                                namespace="chaos-engineering",
                                plural="workflows"
                            )
                            
                            for experiment in experiments.get('items', []):
                                if experiment.get('status', {}).get('phase') == 'Running':
                                    self.monitor_single_experiment(experiment)
                            
                            time.sleep(30)  # Check every 30 seconds
                        
                        except Exception as e:
                            logger.error(f"Monitoring error: {e}")
                            time.sleep(60)
                
                def monitor_single_experiment(self, experiment):
                    """Monitor a single running experiment"""
                    name = experiment['metadata']['name']
                    
                    # Check system health
                    healthy, message = self.check_system_health()
                    
                    if not healthy:
                        logger.warning(f"Triggering rollback for {name}: {message}")
                        self.trigger_emergency_stop()
                
                def trigger_emergency_stop(self):
                    """Trigger emergency stop procedure"""
                    logger.critical("TRIGGERING EMERGENCY STOP")
                    
                    # Delete all chaos experiments
                    try:
                        # Delete workflows
                        self.custom_api.delete_collection_namespaced_custom_object(
                            group="chaos-mesh.org",
                            version="v1alpha1",
                            namespace="chaos-engineering",
                            plural="workflows"
                        )
                        
                        # Delete other chaos types
                        for chaos_type in ['podchaos', 'networkchaos', 'stresschaos', 'iochaos']:
                            self.custom_api.delete_collection_namespaced_custom_object(
                                group="chaos-mesh.org",
                                version="v1alpha1",
                                namespace="chaos-engineering",
                                plural=chaos_type
                            )
                        
                        logger.info("Emergency stop completed")
                    
                    except Exception as e:
                        logger.error(f"Emergency stop failed: {e}")
                
                def run(self):
                    """Main controller loop"""
                    logger.info("Starting guardrails monitoring")
                    self.monitor_experiments()
            
            if __name__ == "__main__":
                controller = ChaosGuardrailsController()
                controller.run()
            EOF
            
            python /app/guardrails_controller.py
        volumeMounts:
        - name: config
          mountPath: /etc/config
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "256Mi"
            cpu: "200m"
      volumes:
      - name: config
        configMap:
          name: chaos-guardrails-config

---
apiVersion: v1
kind: Service
metadata:
  name: chaos-guardrails-webhook
  namespace: chaos-engineering
spec:
  selector:
    app: chaos-guardrails-controller
  ports:
  - port: 8443
    targetPort: 8443
  type: ClusterIP