# Comprehensive Audit Logging Configuration
# Enterprise-grade security audit trail for all credential access and operations

apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-audit-config
  namespace: vault-system
  labels:
    app: vault
    security.3vantage.com/type: audit-logging
data:
  enable-audit.sh: |
    #!/bin/bash
    set -euo pipefail
    
    echo "=== ENABLING VAULT AUDIT LOGGING ==="
    
    # Enable file audit device
    vault audit enable file file_path=/vault/logs/audit.log
    
    # Enable syslog audit device (backup)
    vault audit enable -path=syslog_audit syslog facility=AUTH tag=vault-audit
    
    # Configure audit log retention
    vault write sys/config/auditing \
      default_lease_ttl=768h \
      max_lease_ttl=8760h
    
    echo "âœ… Audit logging enabled"

---
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: vault-audit-forwarder
  namespace: vault-system
  labels:
    app: vault-audit-forwarder
    security.3vantage.com/type: audit-logging
spec:
  selector:
    matchLabels:
      app: vault-audit-forwarder
  template:
    metadata:
      labels:
        app: vault-audit-forwarder
    spec:
      serviceAccountName: vault-audit
      containers:
      - name: fluent-bit
        image: fluent/fluent-bit:2.2.0
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
          allowPrivilegeEscalation: false
        volumeMounts:
        - name: fluent-bit-config
          mountPath: /fluent-bit/etc
        - name: vault-logs
          mountPath: /vault/logs
          readOnly: true
        - name: varlog
          mountPath: /var/log
          readOnly: true
        env:
        - name: NODE_NAME
          valueFrom:
            fieldRef:
              fieldPath: spec.nodeName
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
      volumes:
      - name: fluent-bit-config
        configMap:
          name: fluent-bit-config
      - name: vault-logs
        hostPath:
          path: /var/lib/vault/logs
      - name: varlog
        hostPath:
          path: /var/log

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: fluent-bit-config
  namespace: vault-system
data:
  fluent-bit.conf: |
    [SERVICE]
        Flush         1
        Log_Level     info
        Daemon        off
        Parsers_File  parsers.conf
        HTTP_Server   On
        HTTP_Listen   0.0.0.0
        HTTP_Port     2020

    [INPUT]
        Name              tail
        Path              /vault/logs/audit.log
        Parser            vault-audit
        Tag               vault.audit
        Refresh_Interval  5
        Mem_Buf_Limit     5MB
        Skip_Long_Lines   On

    [FILTER]
        Name    modify
        Match   vault.audit
        Add     source vault-audit
        Add     environment production
        Add     service_type credential-store

    [FILTER]
        Name    grep
        Match   vault.audit
        Regex   type (request|response)

    [OUTPUT]
        Name  stdout
        Match vault.audit
        Format json_lines

    # Send to external SIEM (configure as needed)
    [OUTPUT]
        Name                 http
        Match                vault.audit
        Host                 siem.3vantage.com
        Port                 443
        URI                  /api/v1/vault-audit
        Format               json
        tls                  on
        tls.verify           on
        Header               Authorization Bearer ${SIEM_TOKEN}
        Retry_Limit          3

  parsers.conf: |
    [PARSER]
        Name        vault-audit
        Format      json
        Time_Key    time
        Time_Format %Y-%m-%dT%H:%M:%S.%L%z
        Time_Keep   On

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault-audit
  namespace: vault-system
  labels:
    app: vault-audit

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: vault-audit
rules:
- apiGroups: [""]
  resources: ["pods", "nodes"]
  verbs: ["get", "list", "watch"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault-audit
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: vault-audit
subjects:
- kind: ServiceAccount
  name: vault-audit
  namespace: vault-system

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: audit-log-analyzer
  namespace: vault-system
  labels:
    app: vault-audit-analyzer
    security.3vantage.com/type: security-monitoring
spec:
  schedule: "0 */6 * * *"  # Every 6 hours
  jobTemplate:
    spec:
      template:
        spec:
          serviceAccountName: vault-audit
          restartPolicy: OnFailure
          containers:
          - name: audit-analyzer
            image: python:3.11-slim
            command:
            - /bin/bash
            - -c
            - |
              set -euo pipefail
              
              echo "=== VAULT AUDIT LOG ANALYSIS ==="
              echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
              
              # Install dependencies
              pip install -q jq-py python-dateutil
              
              # Python script for audit analysis
              cat > /tmp/audit_analyzer.py << 'EOF'
              import json
              import sys
              from datetime import datetime, timedelta
              from collections import defaultdict, Counter
              import re
              
              def analyze_audit_logs():
                  suspicious_activities = []
                  access_patterns = defaultdict(list)
                  credential_accesses = []
                  
                  # Read audit log entries from the last 6 hours
                  cutoff_time = datetime.utcnow() - timedelta(hours=6)
                  
                  try:
                      with open('/vault/logs/audit.log', 'r') as f:
                          for line in f:
                              try:
                                  entry = json.loads(line.strip())
                                  
                                  # Parse timestamp
                                  entry_time = datetime.fromisoformat(entry.get('time', '').replace('Z', '+00:00'))
                                  
                                  if entry_time < cutoff_time:
                                      continue
                                  
                                  # Track credential access
                                  if 'production/secrets' in entry.get('request', {}).get('path', ''):
                                      credential_accesses.append({
                                          'time': entry['time'],
                                          'path': entry['request']['path'],
                                          'operation': entry['request']['operation'],
                                          'client_token': entry['request'].get('client_token_accessor', 'unknown'),
                                          'remote_address': entry['request'].get('remote_address', 'unknown')
                                      })
                                  
                                  # Track access patterns
                                  client_token = entry['request'].get('client_token_accessor', 'unknown')
                                  access_patterns[client_token].append({
                                      'time': entry['time'],
                                      'path': entry['request']['path'],
                                      'operation': entry['request']['operation']
                                  })
                                  
                                  # Detect suspicious activities
                                  # Multiple failed authentications
                                  if entry.get('error') and 'authentication' in entry.get('error', '').lower():
                                      suspicious_activities.append({
                                          'type': 'auth_failure',
                                          'time': entry['time'],
                                          'remote_address': entry['request'].get('remote_address'),
                                          'error': entry['error']
                                      })
                                  
                                  # Unusual access times (outside business hours)
                                  hour = entry_time.hour
                                  if hour < 6 or hour > 22:  # Outside 6 AM - 10 PM UTC
                                      if 'production/secrets' in entry.get('request', {}).get('path', ''):
                                          suspicious_activities.append({
                                              'type': 'off_hours_access',
                                              'time': entry['time'],
                                              'path': entry['request']['path'],
                                              'client_token': client_token
                                          })
                                  
                              except (json.JSONDecodeError, KeyError, ValueError) as e:
                                  continue
                  
                  except FileNotFoundError:
                      print("Audit log file not found")
                      return
                  
                  # Generate report
                  print("\n=== AUDIT ANALYSIS REPORT ===")
                  print(f"Analysis period: {cutoff_time.isoformat()} to {datetime.utcnow().isoformat()}")
                  print(f"Total credential accesses: {len(credential_accesses)}")
                  print(f"Unique clients: {len(access_patterns)}")
                  print(f"Suspicious activities: {len(suspicious_activities)}")
                  
                  # Credential access summary
                  if credential_accesses:
                      print("\n--- CREDENTIAL ACCESS SUMMARY ---")
                      paths = Counter(access['path'] for access in credential_accesses)
                      for path, count in paths.most_common():
                          print(f"  {path}: {count} accesses")
                  
                  # Suspicious activities
                  if suspicious_activities:
                      print("\n--- SUSPICIOUS ACTIVITIES ---")
                      for activity in suspicious_activities:
                          print(f"  {activity['type']}: {activity['time']}")
                          if activity['type'] == 'auth_failure':
                              print(f"    Remote: {activity.get('remote_address', 'unknown')}")
                              print(f"    Error: {activity.get('error', 'unknown')}")
                          elif activity['type'] == 'off_hours_access':
                              print(f"    Path: {activity.get('path', 'unknown')}")
                              print(f"    Client: {activity.get('client_token', 'unknown')}")
                  
                  # High-frequency access patterns (potential abuse)
                  print("\n--- ACCESS FREQUENCY ANALYSIS ---")
                  for client, accesses in access_patterns.items():
                      if len(accesses) > 100:  # More than 100 requests in 6 hours
                          print(f"  HIGH FREQUENCY: Client {client[:8]}... made {len(accesses)} requests")
                  
                  # Create alert if critical issues found
                  critical_issues = [a for a in suspicious_activities if a['type'] in ['auth_failure', 'off_hours_access']]
                  if len(critical_issues) > 5:
                      print(f"\nðŸš¨ SECURITY ALERT: {len(critical_issues)} critical security events detected")
                      
                      # In a real implementation, this would trigger alerts
                      with open('/tmp/security_alert.json', 'w') as f:
                          json.dump({
                              'alert_type': 'credential_security_anomaly',
                              'timestamp': datetime.utcnow().isoformat(),
                              'severity': 'high',
                              'events_count': len(critical_issues),
                              'details': critical_issues[:10]  # First 10 events
                          }, f, indent=2)
                      
                      print("Security alert written to /tmp/security_alert.json")
                  
                  else:
                      print("\nâœ… No critical security issues detected")
              
              if __name__ == "__main__":
                  analyze_audit_logs()
              EOF
              
              # Run the analysis
              python /tmp/audit_analyzer.py
              
            volumeMounts:
            - name: vault-logs
              mountPath: /vault/logs
              readOnly: true
          volumes:
          - name: vault-logs
            hostPath:
              path: /var/lib/vault/logs