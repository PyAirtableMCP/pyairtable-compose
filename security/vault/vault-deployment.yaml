# HashiCorp Vault Deployment for PyAirtable
# Production-ready secrets management for 3vantage organization

apiVersion: v1
kind: Namespace
metadata:
  name: vault-system
  labels:
    security.3vantage.com/type: secrets-management

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: vault-config
  namespace: vault-system
data:
  vault.hcl: |
    # Vault Configuration for PyAirtable
    storage "postgresql" {
      connection_url = "postgres://vault:${VAULT_DB_PASSWORD}@postgres.pyairtable-system.svc.cluster.local:5432/vault?sslmode=require"
      table = "vault_kv_store"
      max_parallel = "128"
      ha_enabled = "true"
    }

    listener "tcp" {
      address = "0.0.0.0:8200"
      cluster_address = "0.0.0.0:8201"
      tls_cert_file = "/etc/certs/tls.crt"
      tls_key_file = "/etc/certs/tls.key"
      tls_client_ca_file = "/etc/certs/ca.crt"
      tls_require_and_verify_client_cert = true
      tls_min_version = "tls12"
      tls_cipher_suites = "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384"
    }

    cluster_addr = "https://vault.vault-system.svc.cluster.local:8201"
    api_addr = "https://vault.vault-system.svc.cluster.local:8200"

    ui = true
    disable_mlock = true
    default_lease_ttl = "768h"
    max_lease_ttl = "8760h"

    # Enterprise features (if using Vault Enterprise)
    # license_path = "/etc/vault/license"

    # Audit logging
    # audit {
    #   syslog {
    #     facility = "AUTH"
    #     tag = "vault"
    #   }
    # }

    # Performance settings
    log_level = "INFO"
    log_format = "json"

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: vault
  namespace: vault-system
  labels:
    app: vault
    security.3vantage.com/type: secrets-management
spec:
  serviceName: vault
  replicas: 3
  selector:
    matchLabels:
      app: vault
  template:
    metadata:
      labels:
        app: vault
    spec:
      serviceAccountName: vault
      securityContext:
        runAsNonRoot: true
        runAsUser: 100
        fsGroup: 1000
      containers:
      - name: vault
        image: hashicorp/vault:1.15.2
        imagePullPolicy: IfNotPresent
        ports:
        - name: vault-port
          containerPort: 8200
          protocol: TCP
        - name: cluster-port
          containerPort: 8201
          protocol: TCP
        env:
        - name: VAULT_ADDR
          value: "https://localhost:8200"
        - name: VAULT_API_ADDR
          value: "https://vault.vault-system.svc.cluster.local:8200"
        - name: VAULT_CLUSTER_ADDR
          value: "https://vault.vault-system.svc.cluster.local:8201"
        - name: VAULT_RAFT_NODE_ID
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: VAULT_LOCAL_CONFIG
          value: |
            {
              "backend": {"file": {"path": "/vault/data"}},
              "default_lease_ttl": "168h",
              "max_lease_ttl": "8760h",
              "ui": true
            }
        - name: VAULT_DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: vault-db-credentials
              key: password
        volumeMounts:
        - name: vault-config
          mountPath: /vault/config
          readOnly: true
        - name: vault-certs
          mountPath: /etc/certs
          readOnly: true
        - name: vault-data
          mountPath: /vault/data
        - name: vault-logs
          mountPath: /vault/logs
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "Starting Vault with config:"
          cat /vault/config/vault.hcl
          vault server -config=/vault/config/vault.hcl
        readinessProbe:
          httpGet:
            path: /v1/sys/health?standbyok=true&sealedcode=204&uninitcode=204
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 5
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /v1/sys/health?standbyok=true
            port: 8200
            scheme: HTTPS
          initialDelaySeconds: 60
          periodSeconds: 10
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        securityContext:
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
            add:
            - IPC_LOCK
      volumes:
      - name: vault-config
        configMap:
          name: vault-config
      - name: vault-certs
        secret:
          secretName: vault-tls
      - name: vault-logs
        emptyDir: {}
  volumeClaimTemplates:
  - metadata:
      name: vault-data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi

---
apiVersion: v1
kind: Service
metadata:
  name: vault
  namespace: vault-system
  labels:
    app: vault
spec:
  type: ClusterIP
  ports:
  - name: vault-port
    port: 8200
    targetPort: 8200
    protocol: TCP
  - name: cluster-port
    port: 8201
    targetPort: 8201
    protocol: TCP
  selector:
    app: vault

---
apiVersion: v1
kind: Service
metadata:
  name: vault-active
  namespace: vault-system
  labels:
    app: vault
spec:
  type: ClusterIP
  publishNotReadyAddresses: false
  ports:
  - name: vault-port
    port: 8200
    targetPort: 8200
    protocol: TCP
  selector:
    app: vault
    vault-active: "true"

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: vault
  namespace: vault-system
  labels:
    app: vault

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: vault
rules:
- apiGroups: [""]
  resources: ["pods"]
  verbs: ["list"]
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["create", "get", "list", "patch", "update", "delete"]
- apiGroups: [""]
  resources: ["serviceaccounts"]
  verbs: ["get"]
- apiGroups: [""]
  resources: ["serviceaccounts/token"]
  verbs: ["create"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: vault
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: vault
subjects:
- kind: ServiceAccount
  name: vault
  namespace: vault-system

---
apiVersion: v1
kind: Secret
metadata:
  name: vault-db-credentials
  namespace: vault-system
type: Opaque
data:
  # Generated secure password (base64 encoded)
  # Run: openssl rand -base64 32 | base64 -w 0
  password: VGVtcG9yYXJ5UGFzc3dvcmRDaGFuZ2VNZUluUHJvZHVjdGlvbg==

---
# Vault initialization job
apiVersion: batch/v1
kind: Job
metadata:
  name: vault-init
  namespace: vault-system
spec:
  template:
    spec:
      serviceAccountName: vault
      restartPolicy: OnFailure
      containers:
      - name: vault-init
        image: hashicorp/vault:1.15.2
        env:
        - name: VAULT_ADDR
          value: "https://vault.vault-system.svc.cluster.local:8200"
        - name: VAULT_CACERT
          value: "/etc/certs/ca.crt"
        - name: VAULT_CLIENT_CERT
          value: "/etc/certs/tls.crt"
        - name: VAULT_CLIENT_KEY
          value: "/etc/certs/tls.key"
        volumeMounts:
        - name: vault-certs
          mountPath: /etc/certs
          readOnly: true
        command:
        - /bin/sh
        - -c
        - |
          set -e
          
          echo "Waiting for Vault to be ready..."
          until vault status; do
            sleep 5
          done
          
          echo "Initializing Vault..."
          if ! vault status | grep -q "Initialized.*true"; then
            vault operator init -key-shares=5 -key-threshold=3 -format=json > /tmp/vault-init.json
            
            # Extract keys and root token
            UNSEAL_KEY_1=$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[0]')
            UNSEAL_KEY_2=$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[1]')
            UNSEAL_KEY_3=$(cat /tmp/vault-init.json | jq -r '.unseal_keys_b64[2]')
            ROOT_TOKEN=$(cat /tmp/vault-init.json | jq -r '.root_token')
            
            # Store in Kubernetes secrets
            kubectl create secret generic vault-unseal-keys \
              --from-literal=key1="$UNSEAL_KEY_1" \
              --from-literal=key2="$UNSEAL_KEY_2" \
              --from-literal=key3="$UNSEAL_KEY_3" \
              --namespace=vault-system || true
            
            kubectl create secret generic vault-root-token \
              --from-literal=token="$ROOT_TOKEN" \
              --namespace=vault-system || true
            
            # Unseal Vault
            vault operator unseal "$UNSEAL_KEY_1"
            vault operator unseal "$UNSEAL_KEY_2"
            vault operator unseal "$UNSEAL_KEY_3"
            
            echo "Vault initialized and unsealed successfully"
          else
            echo "Vault already initialized"
          fi
      volumes:
      - name: vault-certs
        secret:
          secretName: vault-tls