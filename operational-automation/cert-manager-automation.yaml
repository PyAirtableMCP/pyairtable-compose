# Certificate Management Automation for PyAirtable
# Provides automated SSL/TLS certificate provisioning and renewal using cert-manager

apiVersion: v1
kind: Namespace
metadata:
  name: cert-manager
  labels:
    name: cert-manager
    pod-security.kubernetes.io/enforce: restricted
    pod-security.kubernetes.io/audit: restricted
    pod-security.kubernetes.io/warn: restricted

---
# Install cert-manager using Helm
apiVersion: helm.cattle.io/v1
kind: HelmChart
metadata:
  name: cert-manager
  namespace: cert-manager
spec:
  chart: cert-manager
  repo: https://charts.jetstack.io
  version: v1.13.0
  targetNamespace: cert-manager
  valuesContent: |-
    installCRDs: true
    replicaCount: 2
    
    resources:
      requests:
        cpu: 10m
        memory: 32Mi
      limits:
        cpu: 100m
        memory: 128Mi
    
    securityContext:
      fsGroup: 1001
      runAsNonRoot: true
      runAsUser: 1001
    
    containerSecurityContext:
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: true
      runAsNonRoot: true
      runAsUser: 1001
    
    prometheus:
      enabled: true
      servicemonitor:
        enabled: true
        labels:
          monitoring: prometheus
    
    webhook:
      replicaCount: 2
      resources:
        requests:
          cpu: 10m
          memory: 32Mi
        limits:
          cpu: 100m
          memory: 128Mi
      securityContext:
        fsGroup: 1001
        runAsNonRoot: true
        runAsUser: 1001
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        readOnlyRootFilesystem: true
        runAsNonRoot: true
        runAsUser: 1001
    
    cainjector:
      replicaCount: 2
      resources:
        requests:
          cpu: 10m
          memory: 32Mi
        limits:
          cpu: 100m
          memory: 128Mi
      securityContext:
        fsGroup: 1001
        runAsNonRoot: true
        runAsUser: 1001
      containerSecurityContext:
        allowPrivilegeEscalation: false
        capabilities:
          drop:
          - ALL
        readOnlyRootFilesystem: true
        runAsNonRoot: true
        runAsUser: 1001

---
# Let's Encrypt Production ClusterIssuer
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-prod
spec:
  acme:
    # Let's Encrypt production server
    server: https://acme-v02.api.letsencrypt.org/directory
    email: ops@pyairtable.com
    
    # Name of a secret used to store the ACME account private key
    privateKeySecretRef:
      name: letsencrypt-prod
    
    # Enable the HTTP-01 challenge provider
    solvers:
    - http01:
        ingress:
          class: nginx
          podTemplate:
            metadata:
              annotations:
                prometheus.io/scrape: "true"
                prometheus.io/port: "8080"
            spec:
              securityContext:
                fsGroup: 1001
                runAsNonRoot: true
                runAsUser: 1001
              containers:
              - name: acme-http01-solver
                securityContext:
                  allowPrivilegeEscalation: false
                  capabilities:
                    drop:
                    - ALL
                  readOnlyRootFilesystem: true
                  runAsNonRoot: true
                  runAsUser: 1001
                resources:
                  requests:
                    cpu: 10m
                    memory: 16Mi
                  limits:
                    cpu: 100m
                    memory: 64Mi
    
    # DNS-01 challenge for wildcard certificates
    - dns01:
        route53:
          region: us-west-2
          accessKeyID: AKIAIOSFODNN7EXAMPLE  # Will be replaced with IRSA
          secretAccessKeySecretRef:
            name: route53-credentials
            key: secret-access-key
          hostedZoneID: Z1D633PJN98FT9
      selector:
        dnsNames:
        - "*.pyairtable.com"
        - "*.dev.pyairtable.com"
        - "*.staging.pyairtable.com"

---
# Let's Encrypt Staging ClusterIssuer (for testing)
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt-staging
spec:
  acme:
    server: https://acme-staging-v02.api.letsencrypt.org/directory
    email: ops@pyairtable.com
    privateKeySecretRef:
      name: letsencrypt-staging
    solvers:
    - http01:
        ingress:
          class: nginx

---
# Self-signed ClusterIssuer for development
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: selfsigned-issuer
spec:
  selfSigned: {}

---
# CA ClusterIssuer for internal services
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: pyairtable-ca-issuer
spec:
  ca:
    secretName: pyairtable-ca-key-pair

---
# Create CA certificate for internal services
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: pyairtable-ca
  namespace: cert-manager
spec:
  isCA: true
  commonName: PyAirtable Internal CA
  secretName: pyairtable-ca-key-pair
  duration: 8760h # 1 year
  renewBefore: 720h # 30 days
  privateKey:
    algorithm: RSA
    size: 4096
  issuerRef:
    name: selfsigned-issuer
    kind: ClusterIssuer
  subject:
    organizationalUnits:
    - Platform Engineering
    organizations:
    - PyAirtable
    countries:
    - US
    provinces:
    - California
    localities:
    - San Francisco

---
# Production certificates
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: pyairtable-com-tls
  namespace: pyairtable-prod
spec:
  secretName: pyairtable-com-tls
  duration: 2160h # 90 days
  renewBefore: 720h # 30 days
  subject:
    organizations:
    - PyAirtable
  commonName: pyairtable.com
  dnsNames:
  - pyairtable.com
  - www.pyairtable.com
  - api.pyairtable.com
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer

---
# Wildcard certificate for production
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: pyairtable-wildcard-tls
  namespace: pyairtable-prod
spec:
  secretName: pyairtable-wildcard-tls
  duration: 2160h # 90 days
  renewBefore: 720h # 30 days
  subject:
    organizations:
    - PyAirtable
  commonName: "*.pyairtable.com"
  dnsNames:
  - "*.pyairtable.com"
  - pyairtable.com
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer

---
# Staging certificates
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: staging-pyairtable-com-tls
  namespace: pyairtable-staging
spec:
  secretName: staging-pyairtable-com-tls
  duration: 2160h # 90 days
  renewBefore: 720h # 30 days
  subject:
    organizations:
    - PyAirtable
  commonName: staging.pyairtable.com
  dnsNames:
  - staging.pyairtable.com
  - "*.staging.pyairtable.com"
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer

---
# Development certificates
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: dev-pyairtable-com-tls
  namespace: pyairtable-dev
spec:
  secretName: dev-pyairtable-com-tls
  duration: 2160h # 90 days
  renewBefore: 720h # 30 days
  subject:
    organizations:
    - PyAirtable
  commonName: dev.pyairtable.com
  dnsNames:
  - dev.pyairtable.com
  - "*.dev.pyairtable.com"
  issuerRef:
    name: letsencrypt-prod
    kind: ClusterIssuer

---
# Internal service certificates
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: internal-services-tls
  namespace: pyairtable-prod
spec:
  secretName: internal-services-tls
  duration: 8760h # 1 year
  renewBefore: 2160h # 90 days
  subject:
    organizations:
    - PyAirtable Internal
  commonName: internal.pyairtable.local
  dnsNames:
  - internal.pyairtable.local
  - "*.internal.pyairtable.local"
  - database.pyairtable.local
  - redis.pyairtable.local
  - kafka.pyairtable.local
  issuerRef:
    name: pyairtable-ca-issuer
    kind: ClusterIssuer

---
# Certificate monitoring and alerting
apiVersion: v1
kind: ConfigMap
metadata:
  name: cert-monitor-config
  namespace: cert-manager
data:
  config.yaml: |
    monitoring:
      check_interval: 300  # 5 minutes
      expiry_warning_days: 30
      renewal_failure_alerts: true
      
    notifications:
      slack_webhook: "https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK"
      email_recipients:
        - "ops@pyairtable.com"
        - "security@pyairtable.com"
        
    certificates:
      critical:
        - "pyairtable-com-tls"
        - "pyairtable-wildcard-tls"
      important:
        - "staging-pyairtable-com-tls"
        - "dev-pyairtable-com-tls"
      internal:
        - "internal-services-tls"

---
# Certificate monitoring deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: cert-monitor
  namespace: cert-manager
  labels:
    app: cert-monitor
    component: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cert-monitor
  template:
    metadata:
      labels:
        app: cert-monitor
        component: monitoring
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: "/metrics"
    spec:
      serviceAccountName: cert-monitor
      containers:
      - name: cert-monitor
        image: python:3.11-slim
        ports:
        - containerPort: 8080
          name: metrics
        command:
        - python
        - /app/monitor.py
        env:
        - name: NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        volumeMounts:
        - name: config
          mountPath: /app/config
          readOnly: true
        - name: monitor-code
          mountPath: /app
          readOnly: true
        resources:
          requests:
            cpu: 50m
            memory: 64Mi
          limits:
            cpu: 100m
            memory: 128Mi
        securityContext:
          allowPrivilegeEscalation: false
          runAsNonRoot: true
          runAsUser: 1000
          capabilities:
            drop:
            - ALL
      volumes:
      - name: config
        configMap:
          name: cert-monitor-config
      - name: monitor-code
        configMap:
          name: cert-monitor-code
          defaultMode: 0755

---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cert-monitor-code
  namespace: cert-manager
data:
  monitor.py: |
    #!/usr/bin/env python3
    """
    Certificate Monitoring Service
    Monitors certificate expiry and renewal status
    """
    
    import os
    import yaml
    import time
    import logging
    import requests
    from datetime import datetime, timedelta
    from kubernetes import client, config
    from prometheus_client import start_http_server, Gauge, Counter
    
    # Configure logging
    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)
    
    # Prometheus metrics
    cert_expiry_days = Gauge('certificate_expiry_days', 'Days until certificate expiry', ['name', 'namespace', 'issuer'])
    cert_renewal_failures = Counter('certificate_renewal_failures_total', 'Certificate renewal failures', ['name', 'namespace'])
    cert_status = Gauge('certificate_status', 'Certificate status (1=ready, 0=not ready)', ['name', 'namespace'])
    
    class CertificateMonitor:
        def __init__(self):
            # Initialize Kubernetes client
            try:
                config.load_incluster_config()
            except:
                config.load_kube_config()
            
            self.v1 = client.CoreV1Api()
            self.custom_api = client.CustomObjectsApi()
            
            # Load configuration
            with open('/app/config/config.yaml', 'r') as f:
                self.config = yaml.safe_load(f)
            
            self.check_interval = self.config['monitoring']['check_interval']
            self.warning_days = self.config['monitoring']['expiry_warning_days']
            
            logger.info("Certificate monitor initialized")
        
        def get_certificates(self):
            """Get all certificates across all namespaces"""
            try:
                response = self.custom_api.list_cluster_custom_object(
                    group="cert-manager.io",
                    version="v1",
                    plural="certificates"
                )
                return response.get('items', [])
            except Exception as e:
                logger.error(f"Error getting certificates: {e}")
                return []
        
        def check_certificate_expiry(self, cert):
            """Check certificate expiry and update metrics"""
            name = cert['metadata']['name']
            namespace = cert['metadata']['namespace']
            
            try:
                # Get certificate status
                status = cert.get('status', {})
                conditions = status.get('conditions', [])
                
                # Check if certificate is ready
                ready = False
                for condition in conditions:
                    if condition['type'] == 'Ready' and condition['status'] == 'True':
                        ready = True
                        break
                
                cert_status.labels(name=name, namespace=namespace).set(1 if ready else 0)
                
                # Check expiry time
                if 'notAfter' in status:
                    expiry_str = status['notAfter']
                    expiry_time = datetime.fromisoformat(expiry_str.replace('Z', '+00:00'))
                    days_until_expiry = (expiry_time - datetime.now(expiry_time.tzinfo)).days
                    
                    # Update metrics
                    issuer = cert['spec']['issuerRef']['name']
                    cert_expiry_days.labels(name=name, namespace=namespace, issuer=issuer).set(days_until_expiry)
                    
                    # Check if renewal is needed
                    if days_until_expiry <= self.warning_days:
                        logger.warning(f"Certificate {name} in {namespace} expires in {days_until_expiry} days")
                        self.send_expiry_alert(name, namespace, days_until_expiry)
                
                # Check for renewal failures
                for condition in conditions:
                    if condition['type'] == 'Issuing' and condition['status'] == 'False':
                        cert_renewal_failures.labels(name=name, namespace=namespace).inc()
                        logger.error(f"Certificate renewal failed for {name} in {namespace}: {condition.get('message', 'Unknown error')}")
                        self.send_renewal_failure_alert(name, namespace, condition.get('message', ''))
                        
            except Exception as e:
                logger.error(f"Error checking certificate {name} in {namespace}: {e}")
        
        def send_expiry_alert(self, name, namespace, days):
            """Send certificate expiry alert"""
            if 'slack_webhook' in self.config['notifications']:
                webhook_url = self.config['notifications']['slack_webhook']
                
                color = "danger" if days <= 7 else "warning"
                message = {
                    "text": f"🚨 Certificate Expiry Warning",
                    "attachments": [{
                        "color": color,
                        "fields": [
                            {"title": "Certificate", "value": name, "short": True},
                            {"title": "Namespace", "value": namespace, "short": True},
                            {"title": "Days Until Expiry", "value": str(days), "short": True},
                            {"title": "Environment", "value": namespace.replace('pyairtable-', ''), "short": True}
                        ]
                    }]
                }
                
                try:
                    requests.post(webhook_url, json=message, timeout=10)
                except Exception as e:
                    logger.error(f"Failed to send Slack alert: {e}")
        
        def send_renewal_failure_alert(self, name, namespace, error_message):
            """Send certificate renewal failure alert"""
            if 'slack_webhook' in self.config['notifications']:
                webhook_url = self.config['notifications']['slack_webhook']
                
                message = {
                    "text": f"❌ Certificate Renewal Failed",
                    "attachments": [{
                        "color": "danger",
                        "fields": [
                            {"title": "Certificate", "value": name, "short": True},
                            {"title": "Namespace", "value": namespace, "short": True},
                            {"title": "Error", "value": error_message[:500], "short": False}
                        ]
                    }]
                }
                
                try:
                    requests.post(webhook_url, json=message, timeout=10)
                except Exception as e:
                    logger.error(f"Failed to send Slack alert: {e}")
        
        def run(self):
            """Run the certificate monitor"""
            # Start Prometheus metrics server
            start_http_server(8080)
            logger.info("Started Prometheus metrics server on port 8080")
            
            while True:
                try:
                    logger.info("Checking certificates...")
                    certificates = self.get_certificates()
                    
                    for cert in certificates:
                        self.check_certificate_expiry(cert)
                    
                    logger.info(f"Checked {len(certificates)} certificates")
                    
                except Exception as e:
                    logger.error(f"Error in monitoring loop: {e}")
                
                time.sleep(self.check_interval)
    
    if __name__ == '__main__':
        monitor = CertificateMonitor()
        monitor.run()

---
# RBAC for certificate monitor
apiVersion: v1
kind: ServiceAccount
metadata:
  name: cert-monitor
  namespace: cert-manager

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: cert-monitor
rules:
- apiGroups: ["cert-manager.io"]
  resources: ["certificates", "certificaterequests", "issuers", "clusterissuers"]
  verbs: ["get", "list", "watch"]
- apiGroups: [""]
  resources: ["secrets"]
  verbs: ["get", "list"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: cert-monitor
subjects:
- kind: ServiceAccount
  name: cert-monitor
  namespace: cert-manager
roleRef:
  kind: ClusterRole
  name: cert-monitor
  apiGroup: rbac.authorization.k8s.io

---
# Service for certificate monitor
apiVersion: v1
kind: Service
metadata:
  name: cert-monitor
  namespace: cert-manager
  labels:
    app: cert-monitor
spec:
  selector:
    app: cert-monitor
  ports:
  - name: metrics
    port: 8080
    targetPort: 8080
  type: ClusterIP

---
# ServiceMonitor for Prometheus
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: cert-monitor
  namespace: cert-manager
  labels:
    app: cert-monitor
    monitoring: prometheus
spec:
  selector:
    matchLabels:
      app: cert-monitor
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
    honorLabels: true

---
# PrometheusRule for certificate alerting
apiVersion: monitoring.coreos.com/v1
kind: PrometheusRule
metadata:
  name: certificate-alerts
  namespace: cert-manager
  labels:
    monitoring: prometheus
spec:
  groups:
  - name: certificate-expiry
    rules:
    - alert: CertificateExpiringSoon
      expr: certificate_expiry_days < 30
      for: 1h
      labels:
        severity: warning
      annotations:
        summary: "Certificate {{ $labels.name }} expiring soon"
        description: "Certificate {{ $labels.name }} in namespace {{ $labels.namespace }} expires in {{ $value }} days"
    
    - alert: CertificateExpiryCritical
      expr: certificate_expiry_days < 7
      for: 0m
      labels:
        severity: critical
      annotations:
        summary: "Certificate {{ $labels.name }} expires very soon"
        description: "Certificate {{ $labels.name }} in namespace {{ $labels.namespace }} expires in {{ $value }} days"
    
    - alert: CertificateNotReady
      expr: certificate_status == 0
      for: 15m
      labels:
        severity: warning
      annotations:
        summary: "Certificate {{ $labels.name }} not ready"
        description: "Certificate {{ $labels.name }} in namespace {{ $labels.namespace }} is not in ready state"
    
    - alert: CertificateRenewalFailure
      expr: increase(certificate_renewal_failures_total[1h]) > 0
      for: 0m
      labels:
        severity: critical
      annotations:
        summary: "Certificate renewal failed"
        description: "Certificate {{ $labels.name }} in namespace {{ $labels.namespace }} renewal has failed"