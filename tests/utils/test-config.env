# PyAirtable Test Configuration
# This file contains test-specific environment variables and placeholder credentials

# =============================================================================
# TEST ENVIRONMENT CONFIGURATION
# =============================================================================

# Test mode flag
TEST_MODE=true

# Test environment designation
TEST_ENVIRONMENT=validation

# Test execution timeout (seconds)
TEST_TIMEOUT=30
TEST_LONG_TIMEOUT=120

# Test retry configuration
TEST_RETRY_COUNT=3
TEST_RETRY_DELAY=2

# Test result output
TEST_RESULTS_DIR=test-results
TEST_LOG_LEVEL=DEBUG

# =============================================================================
# PLACEHOLDER CREDENTIALS FOR TESTING
# These are safe placeholder values for testing service connectivity
# DO NOT use these in production
# =============================================================================

# Placeholder Airtable credentials
TEST_AIRTABLE_TOKEN=pat14.eUyAr1Kn9FgFuUgGdVGj9qAGdVGj9qAGdVGj9qAGdVGj9qAGdVGj9qAGdVGj9qAGdVGj9qAGdVGj9qAG
TEST_AIRTABLE_BASE=appTEST1234567890AB

# Placeholder Gemini API key
TEST_GEMINI_API_KEY=AIzaSyDdI0hCZtE6M1VJCRjfUa-Sl6xV7ABD-xy

# Test API key for service communication
TEST_API_KEY=test-api-key-for-validation-only

# Test JWT secret
TEST_JWT_SECRET=test-jwt-secret-for-validation-only-change-in-production

# Test database passwords (use for Docker Compose testing only)
TEST_POSTGRES_PASSWORD=test-postgres-password
TEST_REDIS_PASSWORD=test-redis-password

# =============================================================================
# TEST SERVICE CONFIGURATION
# =============================================================================

# Service ports for testing
TEST_AIRTABLE_GATEWAY_PORT=8002
TEST_MCP_SERVER_PORT=8001
TEST_LLM_ORCHESTRATOR_PORT=8003
TEST_PLATFORM_SERVICES_PORT=8007
TEST_AUTOMATION_SERVICES_PORT=8006
TEST_FRONTEND_PORT=3000

# Database ports
TEST_POSTGRES_PORT=5432
TEST_REDIS_PORT=6379

# Test service URLs
TEST_AIRTABLE_GATEWAY_URL=http://localhost:8002
TEST_MCP_SERVER_URL=http://localhost:8001
TEST_LLM_ORCHESTRATOR_URL=http://localhost:8003
TEST_PLATFORM_SERVICES_URL=http://localhost:8007
TEST_AUTOMATION_SERVICES_URL=http://localhost:8006

# =============================================================================
# TEST DATA CONFIGURATION
# =============================================================================

# Test session configuration
TEST_SESSION_ID=test-session-$(date +%s)
TEST_USER_ID=test-user-validation

# Test chat messages
TEST_CHAT_MESSAGE_1="Hello, please list all tables in my base"
TEST_CHAT_MESSAGE_2="What is the status of the system?"
TEST_CHAT_MESSAGE_3="Show me the health of all services"

# Test Airtable operations
TEST_TABLE_NAME=TestTable
TEST_RECORD_ID=recTEST1234567890

# =============================================================================
# TEST PERFORMANCE CONFIGURATION
# =============================================================================

# Load testing parameters
TEST_CONCURRENT_USERS=5
TEST_REQUEST_DURATION=30
TEST_RAMP_UP_TIME=10

# Performance thresholds
TEST_MAX_RESPONSE_TIME=5000  # milliseconds
TEST_MIN_SUCCESS_RATE=95     # percentage
TEST_MAX_ERROR_RATE=5        # percentage

# Resource monitoring
TEST_MAX_CPU_USAGE=80        # percentage
TEST_MAX_MEMORY_USAGE=80     # percentage

# =============================================================================
# TEST MOCK DATA
# =============================================================================

# Mock Airtable response structure
TEST_MOCK_TABLE_RESPONSE='{"tables":[{"id":"tblTest123","name":"TestTable","description":"Test table for validation"}]}'

# Mock Gemini response
TEST_MOCK_GEMINI_RESPONSE='{"candidates":[{"content":{"parts":[{"text":"This is a test response from the Gemini API placeholder."}]}}]}'

# Mock health check response
TEST_MOCK_HEALTH_RESPONSE='{"status":"healthy","version":"test","timestamp":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}'

# =============================================================================
# TEST VALIDATION RULES
# =============================================================================

# Expected health check response fields
TEST_REQUIRED_HEALTH_FIELDS="status,version,timestamp"

# Expected service response time (ms)
TEST_EXPECTED_RESPONSE_TIME_HEALTH=500
TEST_EXPECTED_RESPONSE_TIME_CHAT=5000

# Expected HTTP status codes
TEST_EXPECTED_STATUS_HEALTH=200
TEST_EXPECTED_STATUS_CHAT=200
TEST_EXPECTED_STATUS_ERROR=400

# =============================================================================
# TEST ENVIRONMENT OVERRIDES
# =============================================================================

# Override production settings for testing
CORS_ORIGINS=*
REQUIRE_HTTPS=false
LOG_LEVEL=DEBUG
ENABLE_DEBUG=true

# Test-specific rate limiting (more permissive)
DEFAULT_RATE_LIMIT=1000/minute
BURST_RATE_LIMIT=2000/minute

# Test database configuration
POSTGRES_DB=pyairtable_test
POSTGRES_USER=test_user

# Test Redis configuration
REDIS_DB=15  # Use different DB for testing

# =============================================================================
# CONDITIONAL REAL CREDENTIAL LOADING
# =============================================================================

# If real credentials are provided in .env, use them instead of placeholders
# This allows seamless transition from testing to real validation
if [ -n "$AIRTABLE_TOKEN" ] && [ "$AIRTABLE_TOKEN" != "your-airtable-token" ]; then
    export TEST_AIRTABLE_TOKEN="$AIRTABLE_TOKEN"
fi

if [ -n "$AIRTABLE_BASE" ] && [ "$AIRTABLE_BASE" != "appXXXXXXXXXXXXXX" ]; then
    export TEST_AIRTABLE_BASE="$AIRTABLE_BASE"
fi

if [ -n "$GEMINI_API_KEY" ] && [ "$GEMINI_API_KEY" != "your-gemini-api-key" ]; then
    export TEST_GEMINI_API_KEY="$GEMINI_API_KEY"
fi

if [ -n "$API_KEY" ] && [ "$API_KEY" != "your-super-secure-api-key-at-least-32-characters-long" ]; then
    export TEST_API_KEY="$API_KEY"
fi